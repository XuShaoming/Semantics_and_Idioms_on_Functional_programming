(* Dan Grossman, CSE341 Spring 2013, HW2 Provided Code *)(* if you use this function to compare two strings (returns true if the same   string), then you avoid several of the functions in problem 1 having   polymorphic types that may be confusing *)fun same_string(s1 : string, s2 : string) =    s1 = s2(* put your solutions for problem 1 here *)(* Uuse the pattern-matching and the Nested Pattern techniques*)fun all_except_option (x, ys) =    let fun aux (hs) =	    case hs of		[] => []	      | h::hs' => if same_string(h,x) then aux(hs')			  else h::aux(hs')	val res = aux ys		          in if res = ys then NONE       else SOME res    end(*@ is the SML list append*)fun get_substitutions1 (xs, y) =    case xs of	[] => []      | x::xs'  => case all_except_option(y, x) of		       NONE => get_substitutions1(xs',y)			    | SOME res => res @ get_substitutions1(xs',y)(*Use the tail recursive local funtion *)fun get_substitutions2 (xs, y) =    let fun aux (xs, acc) =	    case xs of		[] => acc	      | x::xs' => case all_except_option(y,x) of			      NONE => aux(xs', acc)			    | SOME res => aux(xs', acc @ res)    in aux(xs, [])    end(*Use the scope technique. The inner function can reach outer parameters*)fun similar_names (xs, {first = f, middle = m, last = l}) =    let val ys = get_substitutions2(xs, f)	fun helper zx =	    case zx of		[] => []	      | z::zx' => {first=z, middle=m, last=l} :: helper(zx')    in {first=f, middle=m, last=l} :: helper(ys)    end(* you may assume that Num is always used with values 2, 3, ..., 10   though it will not really come up *)datatype suit = Clubs | Diamonds | Hearts | Spadesdatatype rank = Jack | Queen | King | Ace | Num of int type card = suit * rankdatatype color = Red | Blackdatatype move = Discard of card | Draw exception IllegalMove(* put your solutions for problem 2 here *)(*Use the nested pattern idiom and the wildcard pattern(_)*)fun card_color (crd) =    case crd of	(Clubs,_) => Black      | (Spades,_) => Black       | _ => Red		 (*Nested pattern and wildcard pattern *)fun card_value (crd) =    case crd of	(_, Num i) => i      | (_, Ace) => 11      | _ => 10(*		 fun remove_card (cs, c, e) =    let fun aux (xs,acc) =	    case xs of		[] => raise e	      | x::xs' => if x = c then acc @ xs'			  else aux(xs', acc @ [x])    in aux(cs,[])    end*)(*improve previous code by reduce list append operation Here we use a tail recursive inner funtion.*)fun remove_card (cs, c, e) =    let fun aux (xs, acc) =	    case xs of		[] => raise e	      | x::xs' => if x = c then acc @ xs'			  else aux(xs', x :: acc)    in aux(cs,[])    end(*Nested patterns idiom*)fun all_same_color cs =    case cs of       c::c'::cs' => if card_color(c) = card_color(c')		      then all_same_color(c'::cs')		      else false     | _ => true (*tail recursive locally defined function*)fun sum_cards cs =    let fun aux (cs,acc) =	    case cs of		[] => acc	      | c::cs' => aux(cs', card_value(c) + acc)    in aux(cs, 0)    endfun score (cs, goal) =    let val sum = sum_cards cs	fun sub (a, b) =	    if a > b then 3 * (a - b)	    else b - a    in case all_same_color(cs) of	   true => sub(sum, goal) div 2	 | false => sub(sum, goal)    endfun officiate (cs, ms, goal) =    let fun aux (cs, ms, acc) =	    case (cs,ms) of		([], _) => acc	      | (_, []) => acc	      | (c::cs', m::ms') =>		case m of		    Discard crd => remove_card(acc, crd, IllegalMove)		  | Draw => let val held = c::acc			    in if sum_cards(held) > goal then held			       else aux(cs',ms',held)			    end	val held = aux(cs,ms,[])    in score(held, goal)    end